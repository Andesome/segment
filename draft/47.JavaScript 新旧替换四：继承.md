# 46.JavaScript 新旧替换四：继承
## <a name="index"></a> 目录
- [引子](#start)
- [index 1](#index1)
  - [index 12](#index12)
- [参考资料](#reference)


## <a name="start"></a> 引子
在一些书籍中花费了不少的篇幅进行讲述，新的语法中也出现了相关的关键字，实现的方式中也涉及到 JavaScript 中很重要的知识点。

注意：JavaScript 中并没有类似 Java 中的类和继承，一下用“类”和“继承”是为了方便描述。

<div align="right"><a href="#index">Back to top :arrow_up:</a></div>

## <a name="es5"></a> ES5 方式
实现继承功能的方式也多种，JavaScript 中常用的继承模式是组合继承，这里以此为例。
```js
  function Fruit(name) {
    this.name = name;
  }

  Fruit.prototype.showName = function() {
    console.info("Fruit Name:", this.name);
  };

  function Apple(name, color) {
    Fruit.call(this, name);

    this.color = color;
  }

  Apple.prototype = new Fruit();
  // 矫正语义指向，并不是必需
  Apple.prototype.constructor = Apple;

  Apple.prototype.showColor = function() {
    console.info("Apple Color:", this.color);
  };

  var apple = new Apple("apple", "green");
  console.info("apple:", apple);
  apple.showName();
  apple.showColor();
```
在组合继承中，主要的思路是：
- 创建子类的时候，通过 `Fruit.call(this, name)` 绑定子类实例的 this，达到继承父类属性效果。
- 将父类的实例赋给子类的 `prototype` 属性，子类的实例会沿着原型链查找，达到了继承父类方法的效果。

<div align="right"><a href="#index">Back to top :arrow_up:</a></div>

## <a name="es2015"></a> ES2015+ 方式
用新的语法实现上面的继承：
```js
  class Fruit {
    constructor(name) {
      this.name = name;
    }

    showName() {
      console.info("Fruit Name:", this.name);
    }
  }

  class Apple extends Fruit {
    constructor(name, color) {
      super(name);
      this.color = color;
    }

    showColor() {
      console.info("Apple Color:", this.color);
    }
  }

  let apple = new Apple("apple", "green");
  console.info("apple:", apple);
  apple.showName();
  apple.showColor();
```
在书写形式上有很大的变化，但实际上也是通过原型链实现，通过 Babel 转译为 ES5 看下是怎样的实现思路。

首先说明一下 Babel 中转译有两种模式：normal 和 loose。
- loose 模式下生成更简单、兼容性更好的代码。
- normal 模式下生成符合标准语义的代码。

选择 normal 模式的转译更加合适，先来看下 `Fruit` 类转译后的实现：
```js
"use strict";
/**
 * 对象的 Symbol.hasInstance 属性，指向一个内部方法。
 * 当其他对象使用 instanceof 运算符，判断是否为该对象的实例时，会调用这个方法。
 * 比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。
 */
function _instanceof(left, right) {
  if (
    right != null &&
    typeof Symbol !== "undefined" &&
    right[Symbol.hasInstance]
  ) {
    return !!right[Symbol.hasInstance](left);
  } else {
    return left instanceof right;
  }
}

// 防止直接当方法调用
function _classCallCheck(instance, Constructor) {
  // 判断 instance 是否为 Constructor 的实例
  if (!_instanceof(instance, Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 *
 * Object.defineProperty 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。
 *
 */
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  // 静态方法直接放在构造函数上
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var Fruit =
  /*#__PURE__*/
  (function() {
    function Fruit(name) {
      _classCallCheck(this, Fruit);

      this.name = name;
    }

    _createClass(Fruit, [
      {
        key: "showName",
        value: function showName() {
          console.info("Fruit Name:", this.name);
        }
      }
    ]);

    return Fruit;
  })();
```
在上面转译的代码中，处理的逻辑有：
- `_classCallCheck` 方法判断调用的方式，防止 Fruit() 直接调用。
- `_createClass` 方法在 `prototype` 上添加公用方法，在 `Fruit` 上添加静态方法。

这种方式跟组合使用构造函数模式和原型模式创建对象很相似，不过提供的语义不太一样。

再来看下继承转移后的代码：


<div align="right"><a href="#index">Back to top :arrow_up:</a></div>

## <a name="reference"></a> 参考资料
- [example][url-base]


[url-base]:https://xxholic.github.io/segment/images